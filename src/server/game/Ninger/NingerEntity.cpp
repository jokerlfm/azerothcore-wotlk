#include "NingerEntity.h"
#include "NingerManager.h"
#include "NingerConfig.h"
#include "NingerStrategies/NingerStrategy_Base.h"
#include "NingerActions/NingerAction_Base.h"
#include "NingerActions/NingerAction_Druid.h"
#include "NingerActions/NingerAction_Hunter.h"
#include "NingerActions/NingerAction_Mage.h"
#include "NingerActions/NingerAction_Paladin.h"
#include "NingerActions/NingerAction_Priest.h"
#include "NingerActions/NingerAction_Rogue.h"
#include "NingerActions/NingerAction_Shaman.h"
#include "NingerActions/NingerAction_Warlock.h"
#include "NingerActions/NingerAction_Warrior.h"

#include "Accounts/AccountMgr.h"
#include "Player.h"
#include "Groups/Group.h"
#include "World/World.h"

NingerEntity::NingerEntity()
{
    ninger_id = 0;
    account_id = 0;
    account_name = "";
    character_id = 0;
    target_level = 0;
    target_specialty = 0;
    checkDelay = 5 * IN_MILLISECONDS;
    entityState = NingerEntityState::NingerEntityState_OffLine;
    offlineDelay = 0;
}

void NingerEntity::Update(uint32 pmDiff)
{
    if (offlineDelay >= 0)
    {
        offlineDelay -= pmDiff;
    }
    if (checkDelay >= 0)
    {
        checkDelay -= pmDiff;
    }
    if (checkDelay < 0)
    {
        checkDelay = urand(2 * IN_MILLISECONDS, 10 * IN_MILLISECONDS);
        switch (entityState)
        {
        case NingerEntityState::NingerEntityState_None:
        {
            checkDelay = urand(5 * MINUTE * IN_MILLISECONDS, 10 * MINUTE * IN_MILLISECONDS);
            break;
        }
        case NingerEntityState::NingerEntityState_OffLine:
        {
            break;
        }
        case NingerEntityState::NingerEntityState_Enter:
        {
            entityState = NingerEntityState::NingerEntityState_CheckAccount;
            sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger {} is ready to go online.", account_name.c_str());
            break;
        }
        case NingerEntityState::NingerEntityState_CheckAccount:
        {
            if (account_name.empty())
            {
                entityState = NingerEntityState::NingerEntityState_None;
            }
            else
            {
                uint32 queryAccountId = 0;
                std::ostringstream accountQueryStream;
                accountQueryStream << "SELECT id FROM account where username = '" << account_name << "'";
                QueryResult ningerAccountQR = LoginDatabase.Query(accountQueryStream.str().c_str());
                if (ningerAccountQR)
                {
                    Field* fields = ningerAccountQR->Fetch();
                    queryAccountId = fields[0].Get<uint32>();
                }
                if (queryAccountId > 0)
                {
                    if (account_id != queryAccountId)
                    {
                        account_id = queryAccountId;
                        std::ostringstream sqlStream;
                        sqlStream << "update ninger set account_id = " << account_id << " where ninger_id = " << ninger_id;
                        std::string sql = sqlStream.str();
                        CharacterDatabase.DirectExecute(sql.c_str());
                    }
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger {} is ready.", account_name.c_str());
                    entityState = NingerEntityState::NingerEntityState_CheckCharacter;
                }
                else
                {
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger {} is not ready.", account_name.c_str());
                    entityState = NingerEntityState::NingerEntityState_CreateAccount;
                }
            }
            break;
        }
        case NingerEntityState::NingerEntityState_CreateAccount:
        {
            if (account_name.empty())
            {
                entityState = NingerEntityState::NingerEntityState_None;
            }
            else
            {
                if (AccountMgr::CreateAccount(account_name, NINGER_MARK) == AccountOpResult::AOR_OK)
                {
                    entityState = NingerEntityState::NingerEntityState_CheckAccount;
                }
                else
                {
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger id {} account creation failed.", ninger_id);
                    entityState = NingerEntityState::NingerEntityState_None;
                }
            }
            break;
        }
        case NingerEntityState::NingerEntityState_CheckCharacter:
        {
            std::ostringstream queryStream;
            queryStream << "SELECT guid FROM characters where account = " << account_id;
            QueryResult characterQR = CharacterDatabase.Query(queryStream.str().c_str());
            if (characterQR)
            {
                Field* characterFields = characterQR->Fetch();
                character_id = characterFields[0].Get<uint32>();
                if (character_id > 0)
                {
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger account_id {} character_id {} is ready.", account_id, character_id);
                    entityState = NingerEntityState::NingerEntityState_DoEnum;
                    //entityState = NingerEntityState::NingerEntityState_DoLogin;
                    break;
                }
            }
            sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger account_id {} character_id is not ready.", account_id);
            entityState = NingerEntityState::NingerEntityState_CreateCharacter;
            break;
        }
        case NingerEntityState::NingerEntityState_CreateCharacter:
        {
            std::string currentName = "";
            bool nameValid = false;
            while (sNingerManager->ningerNameMap.find(sNingerManager->nameIndex) != sNingerManager->ningerNameMap.end())
            {
                currentName = sNingerManager->ningerNameMap[sNingerManager->nameIndex];
                std::ostringstream queryStream;
                queryStream << "SELECT count(*) FROM characters where name = '" << currentName << "'";
                QueryResult checkNameQR = CharacterDatabase.Query(queryStream.str().c_str());
                if (!checkNameQR)
                {
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Name {} is available", currentName.c_str());
                    nameValid = true;
                }
                else
                {
                    Field* nameCountFields = checkNameQR->Fetch();
                    uint32 nameCount = nameCountFields[0].Get<uint32>();
                    if (nameCount == 0)
                    {
                        nameValid = true;
                    }
                }
                sNingerManager->nameIndex++;
                if (nameValid)
                {
                    break;
                }
            }
            if (!nameValid)
            {
                sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_ERROR, "No available names");
                entityState = NingerEntityState::NingerEntityState_None;
                return;
            }
            uint8 gender = 0, skin = 0, face = 0, hairStyle = 0, hairColor = 0, facialHair = 0;
            while (true)
            {
                gender = urand(0, 100);
                if (gender < 50)
                {
                    gender = 0;
                }
                else
                {
                    gender = 1;
                }
                face = urand(0, 5);
                hairStyle = urand(0, 5);
                hairColor = urand(0, 5);
                facialHair = urand(0, 5);

                CharacterCreateInfo* cci = new CharacterCreateInfo();
                cci->Name = currentName;
                cci->Race = target_race;
                cci->Class = target_class;
                cci->Gender = gender;
                cci->Skin = skin;
                cci->Face = face;
                cci->HairStyle = hairStyle;
                cci->HairColor = hairColor;
                cci->FacialHair = facialHair;
                cci->OutfitId = 0;

                WorldSession* createSession = new WorldSession(account_id, std::move(account_name), NULL, AccountTypes::SEC_PLAYER, 2, 0, LocaleConstant::LOCALE_enUS, 0, false, true, 0);
                Player* newPlayer = new Player(createSession);
                if (!newPlayer->Create(sObjectMgr->GetGenerator<HighGuid::Player>().Generate(), cci))
                {
                    newPlayer->CleanupsBeforeDelete();
                    delete createSession;
                    delete newPlayer;
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_ERROR, "Character create failed, {} {} {} ", currentName.c_str(), target_race, target_class);
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Try again");
                    continue;
                }
                newPlayer->GetMotionMaster()->Initialize();
                newPlayer->setCinematic(2);
                newPlayer->SetAtLoginFlag(AT_LOGIN_NONE);
                newPlayer->SaveToDB(true, false);
                character_id = newPlayer->GetGUID().GetCounter();
                if (character_id > 0)
                {
                    createSession->isNinger = true;
                    sWorld->AddSession(createSession);
                    std::ostringstream replyStream;
                    replyStream << "ninger character created : account - " << account_id << " character - " << newPlayer->GetGUID().GetCounter() << " " << currentName;
                    std::string replyString = replyStream.str();
                    sWorld->SendServerMessage(ServerMessageType::SERVER_MSG_STRING, replyString.c_str());
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, replyString.c_str());
                    break;
                }
            }
            if (character_id > 0)
            {
                std::ostringstream sqlStream;
                sqlStream << "update ninger set character_id = " << character_id << " where ninger_id = " << ninger_id;
                std::string sql = sqlStream.str();
                CharacterDatabase.DirectExecute(sql.c_str());
                entityState = NingerEntityState::NingerEntityState_CheckCharacter;
                break;
            }
            entityState = NingerEntityState::NingerEntityState_None;
            break;
        }
        case NingerEntityState::NingerEntityState_DoEnum:
        {
            WorldSession* loginSession = sWorld->FindSession(account_id);
            if (!loginSession)
            {
                loginSession = new WorldSession(account_id, std::move(account_name), NULL, AccountTypes::SEC_PLAYER, 2, 0, LocaleConstant::LOCALE_enUS, 0, false, true, 0);
                sWorld->AddSession(loginSession);
            }
            loginSession->isNinger = true;
            WorldPacket wpEnum(CMSG_CHAR_ENUM, 4);
            loginSession->HandleCharEnumOpcode(wpEnum);
            sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Enum character {} {} ", account_id, character_id);
            checkDelay = urand(5 * IN_MILLISECONDS, 10 * IN_MILLISECONDS);
            entityState = NingerEntityState::NingerEntityState_CheckEnum;
            break;
        }
        case NingerEntityState::NingerEntityState_CheckEnum:
        {
            checkDelay = urand(5 * IN_MILLISECONDS, 10 * IN_MILLISECONDS);
            break;
        }
        case NingerEntityState::NingerEntityState_DoLogin:
        {
            WorldSession* loginSession = sWorld->FindSession(account_id);
            if (!loginSession)
            {
                loginSession = new WorldSession(account_id, std::move(account_name), NULL, AccountTypes::SEC_PLAYER, 2, 0, LocaleConstant::LOCALE_enUS, 0, false, true, 0);
                sWorld->AddSession(loginSession);
            }
            loginSession->isNinger = true;
            WorldPacket wpLogin(CMSG_PLAYER_LOGIN, 16);
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            wpLogin << playerGuid;
            loginSession->HandlePlayerLoginOpcode(wpLogin);
            std::ostringstream replyStream;
            replyStream << "log in character : account - " << account_id << " character - " << character_id;
            std::string replyString = replyStream.str();
            sWorld->SendServerMessage(ServerMessageType::SERVER_MSG_STRING, replyString.c_str());
            sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, replyString.c_str());
            checkDelay = urand(5 * IN_MILLISECONDS, 10 * IN_MILLISECONDS);
            entityState = NingerEntityState::NingerEntityState_CheckLogin;
            break;
        }
        case NingerEntityState::NingerEntityState_CheckLogin:
        {
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
            {
                if (me->IsInWorld())
                {
                    std::ostringstream replyStream;
                    replyStream << "ninger character logged in : account - " << account_id << " character - " << character_id;
                    std::string replyString = replyStream.str();
                    sWorld->SendServerMessage(ServerMessageType::SERVER_MSG_STRING, replyString.c_str());
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, replyString.c_str());
                    entityState = NingerEntityState::NingerEntityState_Initialize;
                    break;
                }
            }
            checkDelay = urand(5 * IN_MILLISECONDS, 10 * IN_MILLISECONDS);
            break;
        }
        case NingerEntityState::NingerEntityState_Initialize:
        {
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
            {
                if (me->IsInWorld())
                {
                    me->activeStrategyIndex = 0;
                    me->strategyMap.clear();
                    me->strategyMap[me->activeStrategyIndex] = new NingerStrategy_Base();
                    me->strategyMap[me->activeStrategyIndex]->me = me;
                    me->strategyMap[me->activeStrategyIndex]->Reset();
                    me->strategyMap[StrategyIndex::StrategyIndex_The_Underbog] = new NingerStrategy_The_Underbog();
                    me->strategyMap[StrategyIndex::StrategyIndex_The_Underbog]->me = me;
                    me->strategyMap[StrategyIndex::StrategyIndex_The_Underbog]->Reset();
                    me->strategyMap[StrategyIndex::StrategyIndex_The_Black_Morass] = new NingerStrategy_The_Black_Morass();
                    me->strategyMap[StrategyIndex::StrategyIndex_The_Black_Morass]->me = me;
                    me->strategyMap[StrategyIndex::StrategyIndex_The_Black_Morass]->Reset();
                    me->strategyMap[585] = new NingerStrategy_Magisters_Terrace();
                    me->strategyMap[585]->me = me;
                    me->strategyMap[585]->Reset();
                    me->strategyMap[601] = new NingerStrategy_Azjol_Nerub();
                    me->strategyMap[601]->me = me;
                    me->strategyMap[601]->Reset();
                    switch (target_class)
                    {
                    case Classes::CLASS_DEATH_KNIGHT:
                    {
                        me->ningerAction = new NingerAction_Base(me);
                        break;
                    }
                    case Classes::CLASS_DRUID:
                    {
                        me->ningerAction = new NingerAction_Druid(me);
                        break;
                    }
                    case Classes::CLASS_HUNTER:
                    {
                        me->ningerAction = new NingerAction_Hunter(me);
                        break;
                    }
                    case Classes::CLASS_MAGE:
                    {
                        me->ningerAction = new NingerAction_Mage(me);
                        break;
                    }
                    case Classes::CLASS_PALADIN:
                    {
                        me->ningerAction = new NingerAction_Paladin(me);
                        break;
                    }
                    case Classes::CLASS_PRIEST:
                    {
                        me->ningerAction = new NingerAction_Priest(me);
                        break;
                    }
                    case Classes::CLASS_ROGUE:
                    {
                        me->ningerAction = new NingerAction_Rogue(me);
                        break;
                    }
                    case Classes::CLASS_SHAMAN:
                    {
                        me->ningerAction = new NingerAction_Shaman(me);
                        break;
                    }
                    case Classes::CLASS_WARLOCK:
                    {
                        me->ningerAction = new NingerAction_Warlock(me);
                        break;
                    }
                    case Classes::CLASS_WARRIOR:
                    {
                        me->ningerAction = new NingerAction_Warrior(me);
                        break;
                    }
                    default:
                    {
                        me->ningerAction = new NingerAction_Base(me);
                        break;
                    }
                    }
                    me->ningerAction->InitializeCharacter(target_level, target_specialty);
                    offlineDelay = urand(2 * HOUR * IN_MILLISECONDS, 4 * HOUR * IN_MILLISECONDS);
                    std::ostringstream replyStream;
                    replyStream << "ninger initialized : account - " << account_id << " character - " << character_id << " " << me->GetName();
                    std::string replyString = replyStream.str();
                    sWorld->SendServerMessage(ServerMessageType::SERVER_MSG_STRING, replyString.c_str());
                    sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, replyString.c_str());
                    entityState = NingerEntityState::NingerEntityState_Equip;
                    break;
                }
            }
            entityState = NingerEntityState::NingerEntityState_OffLine;
            break;
        }
        case NingerEntityState::NingerEntityState_Equip:
        {
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
            {
                if (me->IsInWorld())
                {
                    if (me->ningerAction->InitializeEquipments())
                    {
                        for (std::unordered_map<uint32, NingerStrategy_Base*>::iterator nsbIt = me->strategyMap.begin(); nsbIt != me->strategyMap.end(); nsbIt++)
                        {
                            if (NingerStrategy_Base* nsb = nsbIt->second)
                            {
                                nsb->me = me;
                                nsb->initialized = true;
                            }
                        }
                        me->strategyMap[me->activeStrategyIndex]->randomTeleportDelay = urand(2 * IN_MILLISECONDS, 20 * IN_MILLISECONDS);
                        entityState = NingerEntityState::NingerEntityState_Online;
                        std::ostringstream msgStream;
                        msgStream << me->GetName() << " Equiped all slots";
                        sWorld->SendServerMessage(ServerMessageType::SERVER_MSG_STRING, msgStream.str().c_str());
                        break;
                    }
                }
            }
            offlineDelay = 100;
            break;
        }
        case NingerEntityState::NingerEntityState_Online:
        {
            if (offlineDelay > 0)
            {
                checkDelay = urand(10 * MINUTE * IN_MILLISECONDS, 20 * MINUTE * IN_MILLISECONDS);
                ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
                if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
                {
                    if (me->IsInWorld())
                    {
                        me->ningerAction->Prepare();
                        if (Group* myGroup = me->GetGroup())
                        {
                            if (Player* leader = myGroup->GetLeader())
                            {
                                if (leader->GetSession()->isNinger)
                                {
                                    me->RemoveFromGroup();
                                }
                            }
                        }
                    }
                    else
                    {
                        entityState = NingerEntityState::NingerEntityState_Exit;
                    }
                }
            }
            else
            {
                entityState = NingerEntityState::NingerEntityState_Exit;
            }
            break;
        }
        case NingerEntityState::NingerEntityState_Exit:
        {
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
            {
                if (me->IsInWorld())
                {
                    if (me->GetGroup())
                    {
                        entityState = NingerEntityState::NingerEntityState_Online;
                        break;
                    }
                }
            }
            sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_DEBUG, "Ninger {} is ready to go offline.", ninger_id);
            entityState = NingerEntityState::NingerEntityState_DoLogoff;
            break;
        }
        case NingerEntityState::NingerEntityState_DoLogoff:
        {
            checkDelay = urand(10 * IN_MILLISECONDS, 20 * IN_MILLISECONDS);
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
            {
                if (me->IsInWorld())
                {
                    if (WorldSession* ws = me->GetSession())
                    {
                        me->RemoveFromGroup();
                        ws->LogoutPlayer(true);
                        entityState = NingerEntityState::NingerEntityState_CheckLogoff;
                        break;
                    }
                }
            }
            entityState = NingerEntityState::NingerEntityState_OffLine;
            break;
        }
        case NingerEntityState::NingerEntityState_CheckLogoff:
        {
            ObjectGuid playerGuid = ObjectGuid(HighGuid::Player, character_id);
            if (Player* me = ObjectAccessor::FindConnectedPlayer(playerGuid))
            {
                sLog->outMessage(NINGER_MARK, LogLevel::LOG_LEVEL_ERROR, "Log out ninger {} failed", me->GetName());
                entityState = NingerEntityState::NingerEntityState_None;
                break;
            }
            entityState = NingerEntityState::NingerEntityState_OffLine;
            break;
        }
        case NingerEntityState::NingerEntityState_RedoLogin:
        {
            entityState = NingerEntityState::NingerEntityState_OffLine;
            break;
        }
        case NingerEntityState::NingerEntityState_CheckRedoLogin:
        {
            entityState = NingerEntityState::NingerEntityState_OffLine;
            break;
        }
        default:
        {
            checkDelay = urand(5 * MINUTE * IN_MILLISECONDS, 10 * MINUTE * IN_MILLISECONDS);
            break;
        }
        }
    }
}
